Start Server
C:\Windows>3CTftpSvc.exe -s

Stop Server
C:\Windows>3CTftpSvc.exe -e

TFTP BUG: Long transporting mode

TFTP Package Structure:

 2 bytes     string    1 byte     string   1 byte
 ------------------------------------------------
| Opcode |  Filename  |   0  |    Mode    |   0  |
 ------------------------------------------------

. The mode field contains the string "netascii", "octet", or "mail" (or any combination of upper
   and lower case, such as "NETASCII", NetAscii", etc.)

. Max Size = 516 bytes

. Valid RRQ/WRQ packet (PUT):

			      BUG is HERE!
| header |  Filename  | 0 |       Mode      | 0 | 
 \x00\x02  64 61 74 61 00   6F  63 74 65 74   00
	      data\x00         octect\x00

. RecvFrom buf = 516 bytes = 0x204 Max Size

Bug Puntero donde se aloja el buffer final: 018EE990
Bug: Concatena el mensaje de error de 38 bytes + 508 bytes (octet + "A"*508) 
alocando un total de 546 bytes.

Al final de la funcion print_mensaje_error intenta re alinear el stack haciendo un:

add esp, 0x204 # 512 bytes
ret 8

Pero el stack contiene 546 Bytes, por lo que ret termina pisado luego de los 
primeros 512 bytes que estan compuestos por:

  39 Bytes = 36 mensaje de error + 3 bytes para agregar " : " al final del mensaje de error 
+ 473 packet mode 
	(Con esto ya nos comimos los 512 Bytes del  add esp, 0x204 que alinea el stack)
+ 4 bytes para pisar EIP # ret 8
+ 23 bytes (31 - 8 que nos come el ret 8) disponibles para ROP si utilizamos el size maximo del package: 516 bytes.


Explotacion:

El binarion no tiene DEP ni ASLR, al pisar EIP queda un puntero que apunta al 
inicio de nuestro overflow (tftp mode) en ESI.

Basta en colocar un modificar el TFTP MODE para agregar un NOP Sleed + Shellcode y utilizar
EIP para saltar a un jmp ESI o call ESI

Tenemos el gadget:

 push    offset aS
 call    esi

en el siguiente address: 0x00401374

Con esto tenemos todos los ingredientes para hacer nuestro exploit


